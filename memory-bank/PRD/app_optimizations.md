Feedback Unificat – LunarGridTanStack
Rezumat general
Implementarea actuală a LunarGridTanStack a adus îmbunătățiri importante (TanStack Table pentru tabelul lunar, caching cu React Query etc.), dar aplicația încă se confruntă cu probleme majore de comportament și performanță. Pe de o parte, optimizările recente (actualizări manuale de cache în loc de re-fetch, integrarea React useTransition și preîncărcarea lunilor adiacente) sunt prezente
github.com
, însă, pe de altă parte, experiența utilizatorului rămâne nesatisfăcătoare: interfața reacționează lent la acțiuni, editarea inline a celulelor nu funcționează, iar datele afișate par să se deplaseze sau să nu se alinieze corect de la o lună la alta. Feedback-ul de mai jos detaliază aceste probleme, cauzele tehnice din codul actual și recomandă soluții concrete și prioritizate pentru a le remedia, menținând totodată codul simplu și ușor de întreținut.
Probleme detectate în implementarea curentă
Performanță slabă (re-render excesiv): Deși s-au eliminat re-fetch-urile inutile (prin actualizarea cache-ului în loc de invalidateQueries
github.com
), componenta LunarGridTanStack încă re-randează complet întregul grid la orice schimbare, ceea ce provoacă latențe vizibile. Fiecare editare sau navigare declanșează reconstrucția tabelului și recalcularea datelor tuturor celulelor, în loc să actualizeze doar porțiunile schimbate. În cod, observăm indicii ale acestor re-render redundante: de exemplu, un efect sau memo din LunarGridTanStack depindea inițial de referințe instabile (tableCell, tableRow, handleCellClick etc.), ceea ce provoca recalculări frecvente. Aceste dependențe au fost eliminate în ultimul cod
github.com
, semn că ele se schimbau la fiecare randare (nefiind memorate corespunzător). Chiar și cu această ajustare, problema de fond rămâne – referințele și datele folosite în tabel nu sunt optimizate. Dacă datele de intrare sau configurările coloanelor se recreează la fiecare randare, React va reface întregul subarbore al tabelului. Consecința este un UI greoi, care răspunde lent la interacțiuni (ex. întârzieri la introducerea de date sau la schimbarea lunii).
Editarea inline eșuează: Funcționalitatea de a edita valori direct în celulele tabelului nu operează în prezent. Când utilizatorul încearcă să dea click pe o celulă pentru a o edita sau să introducă o valoare, fie nu se întâmplă nimic, fie inputul este imediat pierdut/resetat. Analizând codul, motivul devine clar: nu există o gestionare completă a stării de editare și a mutațiilor de update. În implementarea actuală, există doar hook-ul pentru creare tranzacție (useCreateTransactionMonthly), folosit la adăugarea unei valori noi
github.com
. Lipsește un hook similar pentru actualizarea tranzacțiilor existente – nu am găsit un useUpdateTransaction în cod (semn că editarea efectivă a valorilor existente nu a fost implementată). Astfel, dacă o celulă conține deja o tranzacție, interfața nu știe cum să o modifice. Mai mult, logica de intrare în modul de editare nu este finalizată: de exemplu, event handler-ul pentru click pe celulă a fost simplificat/eliminat (în codul vechi era folosit handleCellClick, acum scos din dependențe
github.com
), ceea ce indică faptul că trecerea în modul “editare” nu mai are loc. Consecința acestor lacune: utilizatorul nu poate modifica direct valorile – fie celula nu devine editabilă la click, fie orice modificare dispare imediat deoarece componenta se re-randează și resetează inputul. Practic, editarea inline este nefuncțională în starea curentă a aplicației.
Date nealiniate și “sărirea” valorilor între luni: Aplicația afișează datele tranzacțiilor pe categorii și zile, însă alinerea acestor date se strică între luni. Utilizatorii observă că valorile “se plimbă” – o categorie care într-o lună apărea pe un anumit rând/coloană, în luna următoare poate fi absentă sau afișată pe alt rând, cauzând confuzie. Cauza principală este modul de construire a rândurilor în tabel după ultimele modificări. Importul store-ului cu toate categoriile a fost eliminat din LunarGridTanStack
github.com
, semn că lista de categorii afișate este acum derivată doar din datele disponibile pentru luna curentă (în loc să fie o listă fixă de categorii). Astfel, dacă o categorie nu are tranzacții într-o anumită lună, acel rând nu se mai afișează deloc. În luna următoare, dacă categoria respectivă are tranzacții, ea reapare, dar posibil pe o altă poziție. Acest comportament dinamic face ca rândurile (sau coloanele) să nu fie consistente de la o lună la alta, ceea ce vizual se traduce prin “deplasarea” valorilor: utilizatorii pot crede că datele s-au amestecat. Pe scurt, nu există o aliniere stabilă a matricei de date – gridul este reconstruit strict pe baza datelor non-goale, fără a păstra poziții fixe pentru categorii (sau zile, dacă ar fi cazul), ducând la un UX confuz.
Lipsă de sincronizare fină între UI și datele din sursă: În forma actuală, se bazează mult pe caching-ul local și actualizări optimiste, dar există cazuri de potențială desincronizare. De exemplu, după ce utilizatorul adaugă o tranzacție nouă, UI-ul lunar o inserează imediat (datorită setQueryData folosit pe cache-ul local). Totuși, dacă există și alte componente care depind de aceleași date (de exemplu, un rezumat total lunar sau o listă globală de tranzacții), acelea nu se actualizează, deoarece optimizarea a eliminat invalidarea globală. În mod similar, dacă apare o eroare la salvarea tranzacției, UI-ul poate deja a fi actualizat optimist și rămâne într-o stare incorectă față de server. Deși React Query menține cache-ul sincron intern, trebuie atenție ca actualizarea făcută cu setQueryData chiar să schimbe referința datelor; altfel, React Query poate considera că nimic nu s-a modificat și nu va declanșa re-randarea componentelor
github.com
. Acest mecanism de “structural sharing” implică faptul că dacă mutația nu creează un nou obiect de date, UI-ul nu va vedea schimbarea. Or, dacă actualizarea cache-ului este făcută greșit (ex: modificând in-place vechiul obiect în loc să creați unul nou), interfața poate rămâne nesincronizată, neafișând tranzacția nou adăugată sau modificată. Pe ansamblu, în implementarea actuală există riscul ca starea UI să nu reflecte mereu fidel starea de pe server sau intențiile utilizatorului, mai ales în scenarii de eroare sau navigare rapidă între luni.
Cauze tehnice profunde
Analizând cauzele din spatele problemelor de mai sus, identificăm câteva aspecte cheie în codul actual:
Referințe instabile și lipsa memoizării: Multe părți din componentă nu sunt memoizate, ceea ce face ca la fiecare randare să se reconstruiască structuri noi (de ex. obiecte de coloană, rânduri, funcții callback). În consecință, chiar și schimbări minore propagă re-randări ample. În cod, dependențe precum tableCell/tableRow (posibil elemente ale TanStack Table) sau handler-ele de evenimente se recreau constant, semn că nu erau înfășurate în useMemo/useCallback. Eliminarea lor din lista de dependențe
github.com
 sugerează că s-a încercat o soluție rapidă, însă problema reală e că respectivele valori ar trebui stabilizate, nu doar scoase din dependențe. Fără referințe stabile, React nu poate compara eficient vechile și noile props, deci va re-randa tot.
Lipsa gestionării stării de editare în UI: Editarea inline necesită păstrarea undeva a stării “acum editez celula X”. În codul curent, fie nu există o astfel de stare globală (ex. în Zustand) sau locală persistentă, fie nu este utilizată. Dacă, spre exemplu, la click pe o celulă nu se setează niciun flag “editingCell”, atunci UI-ul nu știe să afișeze un input. Iar dacă se setează dar imediat se pierde la re-render, iarăși e inutil. Faptul că useRef a fost eliminat din importuri
github.com
 sugerează că poate inițial se încercase stocarea celulei active într-un ref, apoi s-a renunțat. Fără o stare de editare bine gestionată (de ex. un ID de celulă în editare și valoarea curent introdusă), componenta nu poate susține editarea inline. În plus, absența unui hook de mutație pentru update indică și lipsa tratării evenimentului “onSave” al editării – practic, codul nu știe ce să facă cu valoarea editată a unei tranzacții existente.
Reconstruirea completă a matricei de date la schimbarea lunii: Când utilizatorul navighează la o altă lună, se schimbă probabil un parametru (ex. month în state sau context), iar tabelul este regenerat pentru noua lună. În loc să reutilizeze structura existentă, codul curent pare să reconstruiască de la zero datele, fără a păstra ordinea categorii/zile. Asta se întâmplă deoarece lista de categorii afișate vine direct din query-ul de tranzacții lunare, care returnează doar categoriile cu tranzacții. Dacă backend-ul nu furnizează și categoriile goale, atunci frontend-ul nu are logică să le adauge, mai ales după ce a scos dependința de categoryStore global. Rezultatul este un data model incomplet pentru lună, care face UI-ul sensibil la absența unor categorii. Coorodonatele celulelor (rând, coloană) nu mai au repere fixe, deci când trecem la luna următoare, rândul 5, col 3 nu mai corespund neapărat aceleiași categorii/zi ca în luna anterioară. Aceasta este sursa deplasării percepute a datelor. Problema este agravată de faptul că TanStack Table, dacă nu primește chei stabile per rând, va trata tot setul de date ca nou și va re-randa fiecare celulă. Nu există reutilizare la nivel de rânduri între luni, pentru că lipsește un identificator consistent de rând (ex. un ID de categorie) prezent în ambele seturi de date.
Caching optimist implementat parțial: Mutarea de la invalidateQueries la setQueryData pentru adăugarea de tranzacții a eliminat lag-ul de rețea la actualizare, însă trebuie făcută cu grijă. Dacă setQueryData nu produce un nou obiect de date (ex. adăugând tranzacția nouă într-un array existent fără să creezi un array nou), atunci React Query va considera că datele sunt neschimbate datorită structural sharing și nu va notifica componentele dependente
github.com
. Trebuie verificat că implementarea actuală creează un nou array/obiect la inserarea unei tranzacții. În plus, actualizarea cache-ului s-a făcut doar pentru query-ul lunar curent
github.com
. Alte surse de date derivată nu sunt sincronizate: de exemplu, dacă există un query de tip infinite cu toate tranzacțiile sau un total al bugetului, acestea nu se actualizează. Probabil s-a considerat că e acceptabil până la refresh, dar din perspectiva robusteții, e o desincronizare ce trebuie menționată. De asemenea, dacă două mutații au loc rapid (ex. utilizatorul adaugă două tranzacții succesiv), logica de caching trebuie să le acomodeze – de exemplu, să adauge pe cea de-a doua pe baza listei deja actualizate cu prima. Fără atenție, a doua adăugare ar putea suprascrie prima dacă folosește prev stocat înainte de prima mutație. Aceste detalii tehnice trebuie avute în vedere pentru a face soluția robustă.
Evaluarea implementării optimizărilor recente
Noile optimizări adăugate atacă corect problemele identificate, însă implementarea lor în formă actuală este incompletă și, pe alocuri, incompatibilă cu o experiență robustă:
Actualizarea manuală a cache-ului (fără re-fetch): Înlocuirea invalidării cu setQueryData este benefică pentru performanță și a fost realizată în hook-ul de creare tranzacție
github.com
. Acest lucru elimină reîncărcarea datelor de la server la fiecare adăugare, contribuind la fluiditate. Totuși, după cum s-a menționat, trebuie confirmat că această actualizare este făcută corect (immutable). În plus, această optimizare trebuie extinsă și la operațiile de editare și ștergere. În prezent, cum editarea nu este implementată, cache-ul nu are cum să fie actualizat pentru modificări. Dacă s-ar implementa mutația de update fără re-fetch, ar trebui urmat același model (update in cache). Per ansamblu, renunțarea la re-fetch este direcția bună, dar implementarea trebuie completată pentru toate tipurile de mutații și făcută cu grija sincronizării datelor între diferitele view-uri.
useTransition pentru navigarea între luni: Integrarea React 18 useTransition are scopul de a menține UI-ul responsiv și de a evita glitch-urile când se schimbă luna (efectuând tranziția de stare cu prioritate joasă)
github.com
. Aceasta este o practică modernă bună – în teorie, la schimbarea lunii, vechea grilă rămâne afișată până ce noua grilă este pregătită, prevenind un ecran gol sau un freeze. Cu preîncărcarea datelor adiacente, tranziția ar trebui să fie aproape instantanee. Problema este că restul logicii nu profită deplin de useTransition. Dacă calculele pentru noua lună (ex. generarea structurii tabelului) sunt la fel de lente, ele tot se vor executa (doar că neblocant). Ar fi ideal ca aceste calcule să fie ele însele optimizate sau făcute în avans. De asemenea, implementarea trebuie verificată: dacă s-a uitat cumva să se folosească startTransition() în locul potrivit (de ex. la setarea lunii în Zustand sau la schimbarea rutei), tranziția nu produce efectul dorit. Pe baza commit-urilor, integrarea a fost făcută, deci probabil navigarea lunară este mai lină acum, dar impactul useTransition poate fi diminuat de celelalte probleme (ex. re-randările masive). În concluzie, useTransition e implementat corect în sine, dar ca efect vizibil este sabotat de lipsa altor optimizări (UI-ul tot poate părea să reîncarce tot, chiar dacă nu “blochează” complet).
Preîncărcarea („preload”) lunilor adiacente: Această optimizare este în mod clar benefică pentru UX – datele pentru luna anterioară și următoare sunt încărcate anticipat, deci când utilizatorul navighează, are deja informațiile local (evitând așteptarea la fiecare pas)
github.com
. Implementarea pare a fi fost adăugată (probabil via prefetchQuery într-un useEffect dependent de month). Din punct de vedere al corectitudinii, ea nu afectează negativ logica (doar adaugă cache). Trebuie totuși atenție la gestionarea memoriei și actualitatea datelor: dacă utilizatorul navighează mult (ex. 12 luni înainte), s-ar putea acumula multe date în cache. Ar merita setat un cacheTime sau politicile de garbage collection implicit vor elimina datele neutilizate. De asemenea, dacă utilizatorul editează o tranzacție în luna curentă, iar luna următoare era deja preîncărcată, acea preîncărcare ar putea fi stale (dacă editarea afectează și luna următoare, de ex. mutarea unei tranzacții de pe 31 ian pe 1 feb). Aceste cazuri sunt poate rare, dar de menționat. Per total însă, implementarea preloading-ului este corectă și compatibilă cu o experiență fluidă – utilizatorul percepe tranziții rapide între luni și fără încărcări vizibile. Trebuie doar integrată cu restul soluției (de ex., combinată cu useTransition, cred că s-a realizat deja).
Recomandările anterioare (memoizare, optimistic updates, referințe stabile, păstrare stare UI): Majoritatea sfaturilor din prima analiză rămân valabile. S-a început aplicarea unora (cache manual, stabilizarea parțială a dependențelor), dar nu integral. Memoizarea componentelor și a calculelor e încă necesară – de exemplu, definirea coloanelor și a datelor pentru TanStack Table ar trebui făcută cu useMemo pentru a evita recalculări la fiecare randare. În codul actual nu vedem explicit asta, deci probabil se pot adăuga. Referințele stabile pentru callback-uri (ex. un handler de click sau funcție de randare a unei celule editabile) sunt cruciale: dacă la fiecare randare se creează o funcție nouă, componentele copil ne-memorate vor re-randa iar și iar. În commit-ul recent vedem că lista de dependențe a fost redusă
github.com
, dar soluția robustă este să folosești useCallback pentru acele funcții, nu doar să le elimini din dependențe. Optimizarea optimistă (fără așteptarea serverului) este implementată pentru adăugare, dar ar trebui extinsă la update/delete, ceea ce era și înainte recomandat. Păstrarea stării UI – acest aspect este clar în continuare o problemă, dat fiind că editarea se pierde. Soluția recomandată inițial, de a păstra starea de editare separat de datele server (de ex. într-un store local sau context) este încă perfect aplicabilă. Asta asigură că, de exemplu, dacă survine o re-randare cauzată de actualizarea datelor, componenta știe că „celula X era în editare, restaurează un input acolo cu valoarea intermediară”. Părțile din analiza anterioară care priveau separarea clară a state-ului de UI vs. state-ului de server au fost parțial implementate (se folosește Zustand pentru filtre/UI
github.com
), deci direcția e corectă – trebuie doar aplicată și pentru cazul editării inline și al altor interacțiuni.
În sinteză, optimizările actuale merg în direcția bună și nu intră în conflict cu o experiență robustă – ele doar trebuie făcute complete și corecte. Implementarea actuală este încă incompletă (lipsește update, lipsesc memorizări, etc.) și uneori executată superificial (ex. eliminarea unei dependențe în loc de stabilizarea ei). Cu ajustările propuse mai jos, aceste optimizări vor putea cu adevărat să ofere performanța și robustețea scontate.
Recomandări aplicabile (soluții concrete)
Pentru a remedia problemele și a îmbunătăți performanța, recomandăm următoarele acțiuni concrete, adaptate contextului acestui proiect (un singur dezvoltator, soluții simple, fără introducerea unor biblioteci enterprise): 1. Stabilizarea structurii datelor afișate (alinierea categorii/zile): Asigurați-vă că grila lunară afișează un set fix de rânduri și coloane, indiferent dacă există sau nu date în fiecare celulă. Concret, lista de categorii trebuie să fie consistentă între luni. Puteți realiza asta reintroducând sursa de adevăr a categoriilor în generarea tabelului. De exemplu, obțineți toate categoriile utilizatorului fie din categoryStore (dacă păstrați în Zustand toate categoriile bugetare) sau dintr-un endpoint separat, și folosiți această listă ca bază pentru rândurile tabelului. Apoi, maparea datelor lunare se face peste această structură fixă: pentru fiecare categorie și fiecare zi din lună, căutați tranzacția corespunzătoare în datele returnate de query (dacă există, afișați valoarea, dacă nu, afișați 0 sau nimic). Astfel, un anumit rând reprezintă mereu aceeași categorie, și coloana unui anumit număr de zi reprezintă mereu aceeași zi, în toate lunile. Vizual, gridul nu va mai “sări”. Implementare: În useLunarGridTable (sau unde construiți datele tabelului), combinați lista completă de categorii cu datele din useMonthlyTransactions. Puteți crea un array de obiecte de rând de forma { categoryId, valuesByDay: {1: ..., 2: ..., ..., 31: ...} }. Populați valuesByDay folosind tranzacțiile lunare (ex: tranzacția cu categoryId X și day Y dă valoarea). Pentru categoriile fără tranzacții într-o lună, obiectul va avea doar valori default (goale) în valuesByDay. Apoi pasați acest array ordonat fix către TanStack Table ca data. Asigurați-vă că fiecare rând are un id unic stabil (de ex. categoryId) – TanStack Table folosește by default indexul în array ca key dacă nu găsește un getRowId, deci e bine să specificați getRowId: row => row.categoryId la configurarea tabelului. Această modificare va garanta consistența rândurilor și va permite React să reutilizeze rândurile între randări/navigări (dacă key-urile rămân aceleași, nu remontează tot). Rezultatul: valorile vor rămâne în aceeași poziție de la o lună la alta, rezolvând problema “shift”-ului de date. 2. Memoizare și fragmentarea componentelor pentru a evita re-randările costisitoare: Introduceți React.memo și hook-urile de memoizare acolo unde este nevoie pentru a preveni rerandările globale. În special:
Memoizați componentele de nivel de rând și celulă. De exemplu, puteți crea un component separat LunarGridRow care primește o categorie (sau obiectul rând) și afișează intern celulele zilelor folosind TanStack Table’s flexRender. Exportați-l cu React.memo. Astfel, atâta timp cât prop-urile LunarGridRow (categoria și valorile sale) nu se schimbă, acel rând nu se re-renderizează. Dacă utilizați direct TanStack Table pentru randarea rândurilor, puteți aplica memoizarea la funcția de randare a celulelor: cell.getContext().renderValue sau wrapperii de coloană. Important e să evitați ca modificarea unei singure celule să refacă toate celulele.
useMemo pentru datele și coloanele tabelului: Asigurați-vă că definiția coloanelor TanStack (inclusiv accesorii, header, cell renderers) este memorată cu useMemo, deoarece acestea sunt obiecte noi la fiecare randare dacă nu sunt memorate. De exemplu, const columns = useMemo(() => [...], []) – dacă coloanele nu depind de props variabile (sau depind doar de o listă fixă de categorii), le puteți memora o singură dată. Dacă depind de parametri (anul, luna curentă), includeți-le în dependențe astfel încât coloanele să se recalculeze doar când acei parametri se schimbă.
useMemo pentru pregătirea datelor per celule: Dacă faceți pre-calcul (de ex. suma tranzacțiilor per zi, sau formatarea valorilor), folosiți useMemo astfel încât la schimbări minore să nu refaceți calcule costisitoare. De exemplu, dacă extrageți din date structura valuesByDay pentru fiecare rând, memorați acel rezultat pe dependența [monthlyData, fullCategoryList].
Stabilizarea callback-urilor: Orice handler definit în componentă (click pe celulă, blur pe input etc.) trebuie învelit în useCallback cu dependențe minime. De exemplu, const handleCellClick = useCallback((catId, day) => { ...set editing state... }, []). Astfel, referința lui handleCellClick nu se schimbă la fiecare randare. Similar, dacă aveți o funcție de randare custom pentru celule editabile (renderEditableCell), asigurați-vă că este memorată sau definită în afara componentei, ca să nu fie recreată constant.
Aceste măsuri vor reduce dramatic re-randările inutile. Practic, când utilizatorul introduce o valoare într-o celulă, doar acel rând sau chiar doar acea celulă ar trebui să se re-randeze, nu întregul tabel. Când schimbă luna, dacă structura categoriilor este fixă și memorată, doar valorile din fiecare rând se actualizează, posibil fără să remonteze componentele – TanStack Table poate reconcilia rândurile după key și React, prin memo, va actualiza doar unde vede diferențe. Aceasta va îmbunătăți vizibil performanța percepută. 3. Implementarea completă a fluxului de editare inline: Pentru a face editarea să funcționeze, e nevoie de câteva lucruri:
Stare pentru celula aflată în editare: Decideți unde să țineți această stare. Pentru simplitate, se poate folosi un state în componenta LunarGridTanStack: const [editingCell, setEditingCell] = useState<{catId: string, day: number, initialValue: number} | null>(null). Acest obiect reține identificatorul celulei pe care s-a dat dublu-click (sau un click pe un icon de edit) și valoarea inițială a tranzacției (pentru a o putea afișa și eventual reveni la ea dacă se anulează editarea). Alternativ, puteți folosi Zustand pentru acest state dacă doriți acces din mai multe componente (de ex. dacă editați în tabel dar salvați dintr-un formular lateral), însă pentru acum pare suficient local.
Declanșarea modului de editare: Adăugați un event handler pe celulele editabile (ex: onDoubleClick pe o celulă sau pe un buton “edit” în celulă). Acesta va seta editingCell cu identificatorul corespunzător. De exemplu: onDoubleClick={() => setEditingCell({ catId: row.categoryId, day: cellDay, initialValue: cellValue })}.
Afișarea input-ului de editare: În renderer-ul celulei, verificați dacă editingCell corespunde acelei celule. Dacă da, în loc de textul normal, returnați un <input type="number" ...> (sau tipul potrivit) cu valoarea preluată din editingCell.initialValue sau dintr-un state separat pentru valoarea curentă introdusă. Recomandare: folosiți un state separat pentru textul inputului în timpul editării (ex: const [tempValue, setTempValue] = useState(initialValue) atunci când activați editarea, eventual stocat în același obiect editingCell). Astfel, utilizatorul poate edita liber, iar dacă apasă Escape, puteți anula schimbările revenind la initialValue.
Salvarea valorii editate (mutația de update): La onBlur sau onKeyDown Enter pe input, finalizați editarea. Aici intervine logica de mutație. Trebuie să aveți un hook de update pentru tranzacții – implementați useUpdateTransactionMonthly similar cu cel de create. Acesta va apela serviciul API pentru update (ex. TransactionService.update(transactionId, newData)) și, în onSuccess, va actualiza cache-ul monthly transactions la fel ca la create: va înlocui valoarea veche cu cea nouă în lista din cache
github.com
. De asemenea, dacă există un query de total sau alte view-uri afectate, le puteți invalida sau sincroniza aici (ex: queryClient.invalidateQueries(['infiniteTransactions']) pentru a marca lista globală ca needing refresh). După ce porniți mutația de update (updateTransactionMutation.mutate(...)), puteți optimist actualiza imediat UI-ul: de fapt, dacă ați deja setat noua valoare în cache via setQueryData în onSuccess, React Query va re-rendera UI-ul când mutația se întoarce. Dacă doriți feedback instant, puteți folosi onMutate în hook-ul de update: acolo, salvați valoarea veche, și faceți temporar setQueryData cu valoarea nouă (similar cu optimistic update pattern). În cazul unui eșec (onError), reveniți la valoarea veche (pe care ați salvat-o anterior) și arătați un mesaj de eroare.
Ieșirea din modul editare: După ce mutația de update are succes (sau chiar imediat ce utilizatorul a apăsat Enter), setați editingCell înapoi la null ca să închideți inputul. Astfel celula va reveni la modul afișare text. Dacă folosiți optimistic update, valoarea afișată deja va fi cea nouă; dacă nu, oricum onSuccess va fi actualizat cache-ul și va re-randa cu noua valoare.
Cancel edit: (O facilitate utilă, dar opțională pentru început) – dacă utilizatorul apasă Escape sau clic în afara celulei și vrea să renunțe, puteți pur și simplu să nu trimiteți mutația și să resetați editingCell la null. Datorită faptului că nu ați modificat cache-ul (nefiind confirmată vreo schimbare), UI revine la valoarea inițială.
În implementare, asigurați-vă că formularul/input-ul are un UI clar (poate un background diferit sau border) ca utilizatorul să știe că e în modul editare. De asemenea, dezactivați temporar navigarea la altă lună sau adăugarea altei tranzacții cât timp e o editare în curs, pentru a nu pierde modificările accidental. Acest lucru se poate face setând un flag global isEditing când editingCell nu e null, și folosindu-l de exemplu pentru a dezactiva butoanele de schimbare lună. 4. Extinderea mecanismelor de cache pentru toate operațiile (CRUD complet): Acum că aveți create și veți implementa update, gândiți-vă și la ștergerea tranzacțiilor dacă aplicația o cere. Ar trebui un hook useDeleteTransactionMonthly care, în onSuccess, scoate tranzacția ștearsă din cache-ul local al lunii. În plus, revizitați ce alte date derivate există în aplicație și cum pot rămâne sincronizate:
Dacă există un total per lună afișat undeva (suma tuturor tranzacțiilor lunare), acesta ar trebui recalculat local sau invalidat și refăcut de la server după o mutație. Ideal, puteți calcula totalul local din cache (evitând alt query). Dacă preferați simplitatea, puteți invalida un query de total (dacă există) ca să fie refetch-uit.
Dacă există grafic sau alte statistici pe baza tranzacțiilor, asigurați-vă că ori folosesc același cache (React Query permite să share-uiască data între componente) ori invalidați acele query-uri la mutație.
Consistența cross-page: de exemplu, dacă aveți și o pagină “Toate tranzacțiile” (infinit scroll) și un user adaugă sau editează o tranzacție în calendarul lunar, ideal ar fi ca acea tranzacție să apară actualizată și în lista globală. Cea mai simplă cale: la onSuccess în mutațiile de create/update/delete, dați un invalidateQueries pentru lista globală (sau folosiți direct setQueryData dacă doriți să inserați/actualizați și acolo, deși e mai complex). Invalidarea nu e costisitoare dacă lista globală nu e vizibilă în acel moment – se va refetch-ui doar când userul o accesează din nou. Astfel mențineți sincronizarea.
Verificați setările de staleTime pe query-uri: dacă ați lăsat default (0), atunci chiar și după setQueryData, la focus pe fereastră sau după refetch interval, React Query ar putea considera datele stale și să tragă automat din nou de la server. În contextul nostru, poate nu vă doriți asta imediat după ce tocmai ați setat manual datele. Puteți să creșteți staleTime pentru query-urile de tranzacții (ex: câteva minute sau chiar Infinity dacă doriți să nu refetch-uiască deloc fără interacțiune explicită). Alternativ, puteți apela queryClient.invalidateQueries în mod controlat când știți sigur că trebuie refresh (ex: user apasă un buton de “refresh” sau navighează departe și înapoi la pagina asta după mult timp).
Scopul acestor acțiuni este să mențineți o singură sursă de adevăr în cache și să o actualizați coerent. Dacă toate componentele citesc din același cache și îl mențineți corect, veți evita desincronizări. 5. Îmbunătățiri ale navigării între luni și ale feedback-ului către utilizator: După ce ați rezolvat problemele de bază, asigurați și finisajele de UX și robustețe:
Navigare lunară lină: Cu useTransition și prefetch, schimbarea lunii ar trebui deja să fie foarte rapidă. Testați totuși scenariul în care datele pentru luna următoare nu sunt încă disponibile (ex: user sare două luni înainte repede, a doua nu e prefetch-uită). Aplicația ar trebui să afișeze fie un spinner mic pe grid, fie să mențină ultima stare până vine noua (dacă transition funcționează corect, va menține vechea lună până ce noua e gata). Asigurați-vă că starea de pending oferită de useTransition este folosită: const [isPending, startTransition] = useTransition();. De exemplu, dacă isPending este true, puteți afișa în butoanele de navigare o mică animație sau dezactiva temporar interacțiunile până la finalizarea tranziției, prevenind spam-click.
Feedback la salvarea tranzacțiilor: Când utilizatorul adaugă sau editează o tranzacție, oferiți un indiciu că acțiunea s-a efectuat. Exemple: un mesaj toast “Tranzacție adăugată” la succes sau un highlight pe celula nou adăugată. De asemenea, dacă mutația durează vizibil (rețeaua lentă), puteți afișa un mic spinner în interiorul celulei sau pe butonul de “Save”. Pentru asta, puteți folosi starea isLoading/isSuccess din mutațiile React Query. Actualmente, create/update probabil sunt foarte rapide, dar e bine pentru robustețe.
Tratamentul erorilor: Implementați onError în mutații pentru a gestiona problemele (ex: conexiune pierdută, server error). În caz de eroare la adăugare/editare, arătați un mesaj clar (“Nu s-a putut salva, verificați conexiunea”) și eventual oferiți opțiunea de retry. Dacă ați aplicat un optimistic update (ați inserat deja valoarea în UI), la eroare trebuie să o revocați: folosiți datele salvate în onMutate (valoarea veche) ca să restabiliți cache-ul. React Query vă permite să returnați un context în onMutate și să-l folosiți în onError pentru rollback. Asigurați-vă că asemenea situații sunt rare, dar totuși acoperite pentru o experiență robustă.
Prevenirea acțiunilor distructive accidentale: Dacă implementați ștergerea tranzacțiilor (sau resetarea unei valori), cereți o confirmare de la utilizator (un dialog “Sigur ștergeți?”) ca să evitați pierderea de date dintr-un click greșit. E o bună practică ce ține de robustețea UX.
Testare și verificare permanentă: După implementarea modificărilor, testați manual scenarii complexe: adăugare de tranzacție pe o categorie nouă (să apară rândul nou corect), editarea unei tranzacții existente (să își schimbe valoarea și să rămână așa), ștergerea unei tranzacții (să dispară valoarea și dacă era singura din acea categorie, rândul poate rămâne prezent dar gol, conform structurii fixe). Testați navigarea înainte și înapoi între luni, inclusiv imediat după ce ați adăugat sau editat ceva (asigurați-vă că navigarea nu resetează modificările sau că modificările într-o lună nu afectează alta decât dacă trebuie). Având și teste E2E deja în proiect, actualizați-le sau adăugați altele pentru cazurile de editare inline.
Plan de acțiune (pași prioritizați)
În lumina recomandărilor de mai sus, propunem un plan de implementare etapizat, pentru a adresa întâi blocajele critice și apoi optimizările fine: Pasul 1: Corectarea structurii datelor și a aliniamentului categorii/zile.
Scop: Fixarea problemei “data shifting” și pregătirea terenului pentru optimizări ulterioare.
Acțiuni:
Reintrodu starea globală sau lista fixă de categorii în componenta LunarGrid (folosește useCategoryStore sau fetch one-time la mount pentru a obține toate categoriile utilizatorului).
Actualizează hook-ul useLunarGridTable sau logica de generare a datelor tabelului astfel încât să parcurgă toate categoriile și toate zilele lunii. Construiește un array de rânduri complet (chiar dacă pentru unele categorii nu există tranzacții în luna curentă).
Configurează TanStack Table cu getRowId: useCallback(row => row.categoryId, []) (sau echivalent) astfel încât să folosească id-urile categoriilor ca chei. Verifică în consolă sau React DevTools că rândurile au key stabil de la o lună la alta.
Testează manual: navighează între două luni cu seturi de categorii diferite (ex: o lună în care ai tranzacții la categorii A și B, luna următoare doar la B). Vezi că după implementare, în ambele luni tabelul arată categoriile A și B (în luna unde A nu are date, rândul A apare cu valori goale). Confirmă că datele nu mai “săr” de pe un rând pe altul între luni.
Pasul 2: Implementarea fluxului de editare inline (update tranzacție).
Scop: Permite utilizatorului să modifice valorile existente direct în tabel.
Acțiuni:
Creează hook-ul useUpdateTransactionMonthly în useTransactionMutations.ts similar structurii lui useCreateTransactionMonthly. Acesta va folosi useMutation cu funcția de apel API de update (asigură-te că ai o metodă în TransactionService pentru update; dacă nu, creeaz-o).
În onSuccess, fă queryClient.setQueryData pe cache-ul tranzacțiilor lunare curente: caută în lista de tranzacții pe cea cu ID-ul actualizat și înlocuiește-i valoarea cu cea nouă. Returnează o listă nouă (copie) ca să declanșezi re-render
github.com
.
Tot în onSuccess, opțional invalidează alte query-uri relevante (ex: invalidateQueries('infiniteTransactions') dacă e cazul, sau invalidateQueries('monthlySummary') dacă există un sumar lunar separat).
În onMutate, poți implementa optimistic update: salvează vechea valoare și imediat înlocuiește-o în cache cu cea nouă, înainte de răspunsul serverului. (Aceasta e opțională – dacă mutația răspunde foarte rapid, poate nu e nevoie neapărat, dar nu strică pentru consistență).
Gestionează onError – în caz de eșec, fă rollback la valoarea veche în cache (pe care ai salvat-o) și poate trimite un mesaj de eroare.
În componenta LunarGridTanStack, adaugă starea editingCell (sau folosește un store Zustand dedicat UI-ului tabelului, dacă preferi). Implementează logica de intrare/ieșire din editare:
OnDoubleClick pe o celulă -> setEditingCell({catId, day, transactionId, initialValue}). Poți adăuga și transactionId aici ca să știi ce actualizezi. Dacă celula e goală (urmează să creezi tranzacție nouă), poți seta transactionId: null sau un flag separat isNew: true.
Renderer pentru celule: dacă editingCell corespunde, afișează <input> pre-populat cu valoarea (sau gol dacă isNew). Asigură-te că input-ul are autoFocus, ca să poată începe tastarea imediat.
Leagă input-ul de un state local temporar (ex: tempValue) cu onChange. (Alternativ, poți modifica direct o copie a datelor în cache, dar mai sigur e un state separat ca să nu poluezi cache-ul înainte de confirmare).
OnBlur sau onKeyDown Enter pe input -> finalizează editarea:
Dacă transactionId există (editare existentă): apelează updateTransactionMutation.mutate({id: transactionId, value: tempValue, ...}).
Dacă e o celulă nouă (transactionId == null, deci era goală și user a introdus ceva): apelează createTransactionMutation.mutate({catId, date: day, value: tempValue, ...}) – practic reutilizezi fluxul de creare și pentru cazul editării unei celule goale (care e de fapt adăugare). Asigură-te că useCreateTransactionMonthly știe să insereze pe categoria și data respectivă. S-ar putea să trebuiască să îi furnizezi cumva day/cat – vezi dacă TransactionService.create primește acești parametri. Poți extinde payload-ul cu ziua, luna, etc.
Imediat după ce pornești mutația, apelează setEditingCell(null) pentru a închide modul editare. (Dacă vrei, în caz de mutație foarte rapidă, poți chiar aștepta onSuccess înainte de setEditingCell(null) ca să menții input-ul deschis până se salvează – dar probabil nu e nevoie, mai simplu închizi și actualizarea de cache va afișa noua valoare ca text).
OnEscape (dacă user apasă Esc sau vrea să anuleze): setEditingCell(null) fără să trimiți nimic. Asta va reveni la textul inițial deoarece nu ai modificat cache-ul. Dacă ai folosit optimistic update pe mutate, ai grijă să nu fi modificat deja cache-ul – de aceea e mai sigur să faci update-ul cache-ului în onSuccess pentru editare, nu în onMutate, ca să poți anula fără consecințe. (Pentru create e similar – dacă userul a introdus ceva dar apoi a dat Escape, pur și simplu anulezi și nu apelezi createMutation).
Testează fluxul complet:
Editează o tranzacție existentă: schimbă valoarea, apasă Enter. Vezi că se actualizează în UI imediat (dacă optimistic) sau după răspuns. Navighează la altă lună și înapoi, verifică să fie persistată modificarea (și eventual în DB).
Adaugă o tranzacție nouă într-o celulă goală: introdu valoare, Enter. Ar trebui să apară pe loc în UI (folosind fluxul create existent care deja era optimist). Verifică în DB că s-a salvat.
Încearcă să editezi două celule rapid: editează una, înainte să salvezi editează alta. Ar trebui să decidem un comportament – de preferat, să nu permită a doua editare în același timp. Puteți împiedica asta prin faptul că dacă editingCell e setat, ignorați alte double-click-uri. Deci testul ar fi: când o celulă e deja în editare, alt double-click nu face nimic sau apare un toast “Termină editarea curentă întâi”. Asta e pentru robustețe.
Testează și caz de eroare: puteți forța un eșec (de ex. opriți serverul sau puneți o valoare nevalidă dacă API-ul validează). Verificați că la eroare UI-ul revine la valoarea veche și apare mesajul de eroare.
Acest pas este mai complex, dar esențial – odată finalizat, funcționalitatea principală (CRUD pe grid) va fi îndeplinită, și utilizatorul va putea folosi eficient interfața. Pasul 3: Optimizări de performanță și UX suplimentare (memoizare completă, feedback vizual):
Scop: După ce funcționalitatea este corectă, ne asigurăm că performanța și experiența sunt excelente.
Acțiuni:
Aplică memoizarea pe componente: transformă LunarGridTanStack într-un component memo dacă primește props de la un nivel superior (deja este învelit în memo() conform codului
github.com
, deci păstrează asta). Mai important, memorează componentele sub-parti: dacă ai creat LunarGridRow sau chiar LunarGridCell, exportă-le cu React.memo. Confirmă că aceste memo conditions sunt corecte (folosesc shallow compare pe props, ceea ce e ok dacă props sunt primare sau obiecte memoizate).
Verifică cu React DevTools -> Profiler dacă la acțiuni cum ar fi editarea unei celule se re-randează doar componenta așteptată, nu tot gridul. Ajustează dependențele la useMemo/useCallback dacă mai vezi actualizări inutile. De exemplu, dacă vezi că toate rândurile se re-render la editarea uneia, înseamnă că probabil lista de data a tabelului devine un nou obiect complet la fiecare mic update. Asta poate fi greu de evitat, dar dacă ai multe categorii ar merita un truc: poți separa state-ul pe categorii individuale. De exemplu, folosește Zustand pentru a ține o mapă de categoryId -> valori per zile, și fiecare rând se leagă la substatul relevant. Astfel, editarea într-o categorie actualizează doar substatul acela și doar componenta acelui rând vede schimbarea. Aceasta e o optimizare avansată, de tipul “fine-grained state management”. Dacă însă numărul de categorii nu e enorm (<50), s-ar putea să nu fie nevoie de atâta complexitate – reacționează pe baza profilării performanței.
Introdu feedback vizual la interacțiuni: adaugă un <Spinner /> mic sau un schelet de încărcare care apare când isLoading din useMonthlyTransactions e true (prima încărcare a unei luni). Probabil aveți deja ceva implementat (commit-urile menționau loading states testate
github.com
). Asigură-te că la schimbarea lunii, dacă totuși durează puțin, apare clar un indicator de încărcare. Totodată, folosește isPending de la useTransition: de exemplu, dacă isPending e true (tranziție în curs), poți afișa gridul vechi estompat puțin și un text “Loading…” suprapus sau un skeleton peste, pentru a indica tranzitia. Dar asta e cosmetic – important e să nu fie glitch-uri.
La salvarea tranzacției (create/update): dacă vrei feedback, poți face ca butonul Enter sau Confirm (dacă există) să afișeze un spinner mic până la confirmare. Sau mai simplu, imediat ce user apasă Enter, celula iese din editare – dacă mutate ia <200ms, e suficient. Pentru erori, asigură-te că apar mesajele de eroare din onError (poate aveți deja un sistem de toasts centralizat; dacă nu, un simple alert() temporar sau un div roșu e ok, deși nu frumos – totuși pentru producție un toast e indicat).
Imbunătățește navigația rapidă: dacă user vrea să sară direct la o anumită lună (nu doar luna precedentă/următoare), ar fi util fie un selector de lună/an, fie posibilitatea de a apăsa de mai multe ori înainte/înapoi rapid. Asigurați-vă că prefetch-ul nu produce efecte adverse dacă user sare mai mult de o lună: în caz extrem, dacă mergi înainte 3 luni succesiv foarte rapid, doar prima tranziție are data prefetch-uită, următoarele două vor declanșa fetch normal. Ar fi acceptabil, dar puteți extinde prefetch-ul la 2 luni înainte dacă doriți (cu costuri mici). Oricum, e un aspect secundar.
Verifică memoriă/leak-uri: după ce ai navigat prin mai multe luni, deschide dev tools Memory, fă câteva profiluri de memorie. Ar trebui ca vechile date de luni (ex: data de acum 5 luni pe care nu o mai folosești) să fie evict-uită din cache după un timp (default 5 minute pentru React Query). Dacă nu, poți explicit să faci queryClient.removeQueries când știi sigur că nu mai trebuie (dar nu e strict necesar, React Query are grijă). Doar asigură-te că nu păstrezi referințe la vechi state (ex: nu țineți în Zustand ultima lună vizitată dacă nu e necesar).
Pasul 4: Refactorizări minore și curățenie în cod:
Scop: Simplificarea logicii și prevenirea viitoarelor bug-uri.
Acțiuni:
Odată ce totul merge, curăță codul de comentarii învechite sau console.log-uri folosite la debug. Actualizează documentația (README sau documentația internă) pentru a reflecta noul comportament – de exemplu, menționează că se folosește caching optimist și că editarea inline este suportată.
Verifică testele unitare/E2E. Dacă există teste care au fost temporar dezactivate sau marcate ca “expected to fail” din cauza bug-urilor anterioare (de ex., test E2E care verifică editarea unei celule), reactivează-le și asigură-te că trec. Adaugă teste noi: ar fi util un test E2E care să verifice că după editarea unei valori, aceasta persistă și că totalul (dacă e afișat) se actualizează.
Revizuiește și stabilizează API-urile interne: de exemplu, acum că ai useCreateTransactionMonthly și useUpdateTransactionMonthly, vezi dacă le poți unifica într-un singur hook useTransactionMutations care să le includă pe ambele (poate returnează {createMonthly, updateMonthly, deleteMonthly}). Nu este critic, doar pentru îngrijirea codului. Ai grijă însă la naming clar – prefixul “Monthly” e ok să distingă de eventuale mutații care afectează alte view-uri.
Asigură-te că datele introduse sunt validate fie la nivel UI, fie la nivel API. De exemplu, dacă cineva introduce o valoare negativă sau un string în input numeric, cum e tratat? Ar fi bine să pui un type="number" și eventual min="0" dacă logica business cere doar numere pozitive. La fel, asigură-te că nu se pot crea tranzacții în viitor (dacă nu e permis) sau duplicate accidental (dacă user apasă Enter de două ori repede – ai putea dezactiva inputul sau butonul de salvare după primul submit până la răspuns). Aceste detalii țin de robustețea aplicației în fața inputurilor imprevizibile.
Ordinea acestor pași este gândită pentru a adresa mai întâi problemele critice de corectitudine (data alignment, editare), apoi performanța, apoi UX. În funcție de cum decurge implementarea, unele pot fi făcute în paralel (de exemplu, pasul 1 și 2 pot fi implementate în tandem: când creezi structura fixă de categorii, deja ai contextul propice să implementezi și editarea). Important este să testezi temeinic după fiecare schimbare majoră, pentru a izola eventualele regresii.
Tips de stil, UX și robustețe
În încheiere, câteva bune practici de stil și experiență, pentru a lustrui soluția:
Păstrează UI-ul curat și intuitiv: Asigură-te că modurile de editare sunt ușor de înțeles. Poate adaugă un icon de creion când faci hover pe o celulă editabilă, ca utilizatorul să știe că poate edita. De asemenea, diferențiază vizual o celulă goală (poate afișezi un - sau un placeholder “Adaugă”) ca să fie clar că e interactivă, versus celulele non-editabile (dacă există în tabel vreo coloană total sau ceva care nu se editează manual).
Consistența design-ului: Dacă aplicația folosește un design system (Tailwind util classes sunt deja folosite după cum văd), menține același stil la noile elemente. Input-urile de editare ar trebui stilizate similar cu cele din alte părți ale aplicației (ex: aceeași bordură, focus state etc.). Folosește utilitare existente (dacă aveți design tokens pentru culori/mărimi) pentru a integra noile componente.
Preîntâmpină acțiunile neașteptate ale utilizatorului: Gândește-te ce se întâmplă dacă utilizatorul încearcă să facă lucruri neprevăzute. De exemplu, dacă e în modul editare la o celulă și apoi dă clic pe altă lună din meniul principal (navigând departe) – ideal ar fi să salvezi automat sau să avertizezi “Ai modificări nesalvate, ești sigur că schimbi luna?”. Poate în contextul aplicației de buget, utilizatorul va edita o lună deodată, dar e bine să fim siguri că nu pierdem date. O simplă soluție: dacă isEditing (din store) e true și user schimbă luna, interceptăm acțiunea și fie salvăm automat modificarea, fie afișăm un confirm. Implementarea poate fi complexă, deci ca minim, documentează această limitare sau împiedică navigarea dacă e ceva în curs (de ex., disable navigarea cât timp editingCell != null).
Optimizare continuă cu date reale: După ce soluția e implementată, testează cu un volum mai mare de date realist. Populatează baza de date cu, să zicem, 100 de categorii și tranzacții pe 6 luni, și vezi cum se comportă. Dacă devine greoi, atunci e semn că trebuie adăugat virtualizare (TanStack Table se poate integra cu react-virtual pentru a afișa doar rândurile vizibile). Virtualizarea e “hyper-complexă” comparat cu ce avem acum, deci nu o implementa decât la nevoie. Dar e bine de știut că există opțiunea, în caz că se scalează aplicația.
Cod simplu și comentat: Ține codul ușor de parcurs. Ai deja modulare bună (hooks separate, servicii). Continuă în acest fel: dacă o funcție devine prea lungă sau face două lucruri, împarte-o. De exemplu, logica de generare a matricei de date poate fi într-un helper buildMonthlyMatrix(data, categories) – ușor de testat independent. Adaugă comentarii succinte unde logica e complexă (ex: “// On double-click, enter edit mode for the clicked cell”). Aceste explicații îi vor prinde bine atât ție în viitor, cât și oricărui coleg sau chiar AI-ul de asistență, pentru a înțelege intenția codului.
Respectarea scenariilor de utilizare definite: Reamintește-ți obiectivul aplicației de bugetare și asigură-te că noile comportamente se aliniază așteptărilor utilizatorului final. De exemplu, dacă aplicația are conceptul de “buget lunar planificat” vs “cheltuieli efective”, clarifică ce editează utilizatorul în acest grid – planul sau efectivul? În funcție de asta, etichetează corespunzător (poate titlul tabelului să indice luna și tipul de date). Un UX robust înseamnă și comunicare clară în interfață: stări goale (“Nu ai tranzacții în această categorie luna aceasta” dacă vrei să explici de ce rândul e gol), mesaje de succes (“Tranzacția a fost salvată”) etc.
Testare E2E a fluxurilor principale: După implementare, ar fi ideal să ai un scenariu de test end-to-end automatizat care: adaugă o tranzacție, o editează, o șterge, navighează înainte și înapoi, și verifică că valorile afișate sunt corecte la fiecare pas. Acest test vă va proteja contra regresiilor viitoare pe această componentă complexă.
Aplicând aceste recomandări, componenta LunarGridTanStack ar trebui să devină mult mai fiabilă și rapidă. Utilizatorii vor putea interacționa fluent cu datele lor financiare lunare – adăugând și modificând valori imediat, cu UI reacționând fără întârzieri vizibile – iar dezvoltatorul va avea un cod mai clar și previzibil, ușor de extins pe viitor. Ajustările propuse evită soluțiile complicate și se bazează pe API-urile deja utilizate (React Query, Zustand, TanStack Table), aliniindu-se cu un stack modern și eficient. Rezultatul final va fi o experiență de bugetare performantă, robustă și plăcută vizual, fără comportamente surprinzătoare sau frustrante.